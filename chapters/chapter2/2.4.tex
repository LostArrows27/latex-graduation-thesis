\section{Tổng kết}

Chương này đã cung cấp một cái nhìn tổng quan về kiến trúc microservice và vai trò quan trọng của giao tiếp trong kiến trúc này. Chúng ta đã thảo luận về các đặc điểm chính của microservices, so sánh với kiến trúc nguyên khối, và xem xét các lợi ích cũng như thách thức.

Về mặt đặc điểm, microservice là một kiến trúc phân tán, trong đó mỗi dịch vụ tự trị, tập trung vào một chức năng nghiệp vụ cụ thể, quản lý dữ liệu riêng của nó, được thiết kế để xử lý lỗi, và có thể phát triển độc lập. So với kiến trúc nguyên khối, microservice cung cấp khả năng mở rộng có mục tiêu, phát triển nhanh hơn, tính linh hoạt công nghệ, khả năng chịu lỗi tốt hơn, và khả năng bảo trì và hiểu biết tốt hơn.

Tuy nhiên, microservice cũng đặt ra một số thách thức, bao gồm độ phức tạp phân tán, giao tiếp giữa các dịch vụ, quản lý dữ liệu, vận hành và giám sát, và kiểm thử. Để giải quyết những thách thức này, một số nguyên tắc thiết kế nên được tuân thủ, bao gồm Single Responsibility Principle, Domain-Driven Design, API First, tự động hóa, Monitoring và Observability, và Fault Tolerance.

Trong phần về giao tiếp, chúng ta đã khám phá vai trò quan trọng của giao tiếp trong kiến trúc microservice, bao gồm tạo điều kiện cho sự hợp tác giữa các dịch vụ, đảm bảo tính nhất quán dữ liệu, hỗ trợ khả năng chịu lỗi, và cho phép tính mở rộng. Chúng ta cũng đã thảo luận về các thuộc tính quan trọng của giao tiếp microservice, bao gồm độ tin cậy, độ trễ, khả năng mở rộng, cách ly lỗi, tính nhất quán, định dạng dữ liệu, khả năng tương tác, và bảo mật.

Hai mô hình giao tiếp cơ bản trong microservices là đồng bộ và bất đồng bộ. Trong giao tiếp đồng bộ, người gửi đợi phản hồi từ người nhận, trong khi trong giao tiếp bất đồng bộ, người gửi không đợi phản hồi. Ngoài ra, các microservice cũng giao tiếp theo các kiểu tương tác khác nhau, bao gồm one-to-one, one-to-many, many-to-one, và many-to-many.

Chúng ta đã đi sâu vào các mẫu giao tiếp cụ thể trong microservices, bao gồm Request-Response, Event-Driven, Publish-Subscribe, Point-to-Point Messaging, và Asynchronous Request-Response. Mỗi mẫu có ưu và nhược điểm riêng, thích hợp cho các tình huống và yêu cầu khác nhau.

Trong phần về công nghệ triển khai, chúng ta đã khám phá các công nghệ hiện đại được sử dụng để xây dựng hệ thống microservices. NestJS được giới thiệu như một framework mạnh mẽ dựa trên Node.js và TypeScript, cung cấp kiến trúc mô-đun và hỗ trợ tích hợp cho nhiều phương thức giao tiếp. TypeScript mang lại lợi thế với hệ thống kiểu dữ liệu tĩnh, giúp phát hiện lỗi sớm và cải thiện khả năng bảo trì code. Về phần cơ sở dữ liệu, TypeORM được sử dụng như một ORM hiện đại kết hợp với PostgreSQL để lưu trữ dữ liệu một cách hiệu quả.

Các công nghệ giao tiếp được trình bày bao gồm HTTP/REST với Axios cho giao tiếp đồng bộ, RabbitMQ cho các mẫu Point-to-Point và Asynchronous Request-Response, và Apache Kafka cho các mẫu Publish/Subscribe và Event-Driven. Mỗi công nghệ có đặc điểm và ưu điểm riêng, phù hợp với các mẫu giao tiếp tương ứng.

Trong phần về đo lường hiệu năng, chúng ta đã thảo luận chi tiết về các thông số đo lường chính, bao gồm Latency, Throughput, Error Rate, Resource Utilization, Scalability và Consistency. Mỗi thông số được phân tích theo nhiều khía cạnh và ý nghĩa của chúng trong context của microservices, cùng với sự ảnh hưởng của các mẫu giao tiếp khác nhau đến các thông số này.

Chúng ta cũng đã khám phá chi tiết các phương pháp đo lường, bao gồm Load Testing với các phương pháp như kiểm thử tăng dần, kiểm thử chịu tải, kiểm thử phá vỡ và kiểm thử độ bền. Benchmarking được trình bày như một phương pháp so sánh hiệu năng dưới các điều kiện tiêu chuẩn. Profiling giúp phân tích chi tiết về tài nguyên sử dụng và thời gian thực thi. Distributed Tracing theo dõi yêu cầu xuyên suốt các dịch vụ, và Metrics Collection thu thập và phân tích các chỉ số hiệu năng theo thời gian.

Về công cụ đo lường, K6 được giới thiệu như một công cụ kiểm thử tải mạnh mẽ, cho phép viết các tập lệnh kiểm thử phức tạp bằng JavaScript. Prometheus là hệ thống giám sát mở rộng cao và đáng tin cậy, sử dụng mô hình pull để thu thập số liệu và cung cấp ngôn ngữ truy vấn PromQL mạnh mẽ.

Các khái niệm và hiểu biết từ chương này sẽ làm nền tảng cho các chương tiếp theo, nơi chúng ta sẽ đi sâu vào việc phân tích chi tiết các mẫu giao tiếp cụ thể trong kiến trúc microservice. Chúng ta sẽ phân loại các mẫu này theo tiêu chí đồng bộ/bất đồng bộ và one-to-one/one-to-many, phân tích ưu và nhược điểm của từng mẫu, và cung cấp hướng dẫn cho việc lựa chọn mẫu phù hợp cho các tình huống cụ thể.

Việc hiểu rõ các khái niệm cơ bản, công nghệ triển khai và phương pháp đo lường hiệu năng sẽ giúp chúng ta đánh giá tốt hơn hiệu quả của các mẫu giao tiếp trong các kịch bản thực tế. Các công nghệ như NestJS, TypeORM, RabbitMQ và Kafka, cùng với các công cụ đo lường như K6 và Prometheus, sẽ được ứng dụng trong các phần tiếp theo để triển khai và đánh giá các mẫu giao tiếp trong môi trường thực tế.

Tóm lại, chương này đã cung cấp một cái nhìn toàn diện về kiến trúc microservice, vai trò quan trọng của giao tiếp, các công nghệ triển khai hiện đại và phương pháp đo lường hiệu năng. Những kiến thức này sẽ là nền tảng vững chắc cho các phân tích chi tiết hơn trong các chương tiếp theo, giúp chúng ta hiểu rõ hơn về cách triển khai và đánh giá các mẫu giao tiếp trong kiến trúc microservice.