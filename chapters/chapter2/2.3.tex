\section{Công nghệ và phương pháp đo lường hiệu năng}

\subsection{Các công nghệ triển khai trong dự án}
Trong triển khai kiến trúc vi dịch vụ, việc lựa chọn công nghệ phù hợp đóng vai trò quan trọng, ảnh hưởng trực tiếp đến hiệu suất, khả năng mở rộng và bảo trì của hệ thống \cite{newman2015}. Khóa luận sử dụng NestJS làm framework chính cho việc phát triển microservices, một framework Node.js tiến bộ dựa trên TypeScript, cung cấp kiến trúc ứng dụng lấy cảm hứng từ Angular với các nguyên tắc SOLID và mô hình MVC. Framework này mang lại lợi ích như hỗ trợ dependency injection, kiến trúc mô-đun hóa cao và tích hợp sẵn với nhiều công nghệ khác.

Mỗi dịch vụ được triển khai như một ứng dụng NestJS độc lập, với cấu trúc gồm controllers (xử lý yêu cầu HTTP), services (chứa logic nghiệp vụ), modules (đóng gói thành phần liên quan) và entities (đại diện đối tượng dữ liệu). NestJS cung cấp module microservices chuyên dụng hỗ trợ các giao thức như TCP, Redis, MQTT, gRPC, và Kafka, giúp đơn giản hóa việc triển khai các mẫu giao tiếp.

TypeScript được chọn làm ngôn ngữ lập trình chính với ưu điểm hệ thống kiểu dữ liệu tĩnh, giúp phát hiện lỗi sớm, tăng cường khả năng đọc hiểu và bảo trì mã nguồn. Trong môi trường microservices, TypeScript giúp đảm bảo tính nhất quán của dữ liệu được truyền giữa các dịch vụ thông qua các contract rõ ràng.

Về lưu trữ dữ liệu, nguyên tắc "mỗi dịch vụ có cơ sở dữ liệu riêng" được tuân thủ. TypeORM được sử dụng để tương tác với cơ sở dữ liệu, hỗ trợ nhiều hệ quản trị và cung cấp tính năng như quan hệ, kế thừa, migrations. TypeORM sử dụng cả Active Record và Data Mapper, hỗ trợ lazy/eager loading, transactions và query builder để tối ưu hóa hiệu suất truy vấn.

PostgreSQL được chọn làm hệ quản trị cơ sở dữ liệu chính do tính ổn định, hiệu suất cao và hỗ trợ dữ liệu phức tạp (JSON, JSONB, arrays). Khả năng xử lý đồng thời và transaction của PostgreSQL đảm bảo tính nhất quán dữ liệu trong môi trường phân tán.

Về giao tiếp giữa microservices, khóa luận sử dụng nhiều công nghệ cho các mẫu giao tiếp khác nhau. HTTP/REST API là nền tảng cho giao tiếp đồng bộ, với Axios làm HTTP client. RabbitMQ được triển khai cho mẫu Point-to-Point và Asynchronous Request-Response, cung cấp cơ chế tin cậy cao với xác nhận tin nhắn và hàng đợi bền vững. Apache Kafka được sử dụng cho Publish/Subscribe và Event-Driven, nổi bật với khả năng xử lý hàng triệu sự kiện mỗi giây, độ trễ thấp và lưu trữ sự kiện lâu dài.

\subsection{Các thông số đo lường chính}
Để đánh giá hiệu năng của các mẫu giao tiếp, khóa luận xem xét một tập hợp thông số toàn diện. Latency (Độ trễ) là thông số quan trọng nhất, đại diện cho thời gian cần thiết để hoàn thành một yêu cầu, từ khi gửi đến khi nhận phản hồi \cite{jun2018}. Độ trễ được phân tích theo nhiều khía cạnh: độ trễ đầu cuối (tổng thời gian từ client đến phản hồi), độ trễ dịch vụ (thời gian xử lý trong một microservice) và độ trễ mạng (thời gian di chuyển dữ liệu giữa dịch vụ).

Throughput (Thông lượng) đo lường số lượng yêu cầu hệ thống xử lý trong một đơn vị thời gian, biểu thị bằng yêu cầu/giây (RPS) hoặc giao dịch/giây (TPS) \cite{jun2018}. Thông lượng được đo ở nhiều cấp độ: hệ thống, dịch vụ và endpoint. Các mẫu giao tiếp khác nhau ảnh hưởng đáng kể đến thông lượng - mẫu đồng bộ thường có thông lượng thấp hơn, mẫu bất đồng bộ có thể đạt thông lượng cao hơn nhờ xử lý song song.

Error Rate (Tỷ lệ lỗi) là tỷ lệ phần trăm yêu cầu thất bại so với tổng số yêu cầu \cite{newman2015}. Tỷ lệ lỗi bị ảnh hưởng bởi lỗi mạng, lỗi dịch vụ, timeout hoặc lỗi logic nghiệp vụ \cite{richardson2019}. Mỗi loại lỗi (mạng, timeout, dịch vụ, logic) cần được phân loại và xử lý riêng biệt. Các mẫu giao tiếp khác nhau có cách tiếp cận khác nhau đối với xử lý lỗi, từ HTTP status codes đến dead-letter queues.

Resource Utilization (Sử dụng tài nguyên) đề cập đến lượng tài nguyên hệ thống (CPU, bộ nhớ, băng thông mạng) được sử dụng. Khóa luận giám sát sử dụng tài nguyên cho từng microservice và toàn hệ thống. Các mẫu giao tiếp đồng bộ thường có yêu cầu CPU/bộ nhớ thấp hơn nhưng nhiều kết nối mạng, mẫu bất đồng bộ có thể yêu cầu CPU/bộ nhớ cao hơn nhưng sử dụng mạng hiệu quả hơn.

Scalability (Khả năng mở rộng) đo lường khả năng xử lý tải tăng khi thêm tài nguyên. Khả năng mở rộng theo chiều ngang (thêm instance) thường được ưu tiên hơn chiều dọc (thêm tài nguyên cho instance hiện có). Các mẫu bất đồng bộ thường có khả năng mở rộng tốt hơn do tạo ít phụ thuộc trực tiếp giữa dịch vụ.

Consistency (Tính nhất quán) là khả năng duy trì trạng thái dữ liệu đồng bộ giữa các dịch vụ. Khóa luận đánh giá mức độ nhất quán dữ liệu đạt được bởi các mẫu giao tiếp khác nhau, từ tính nhất quán mạnh (strong consistency) đến nhất quán cuối cùng (eventual consistency).

\subsection{Phương pháp đo lường}
Khóa luận áp dụng nhiều phương pháp bổ sung nhau để thu thập dữ liệu hiệu năng \cite{newman2015}. Load Testing (Kiểm thử tải) mô phỏng điều kiện tải thực tế và đánh giá hiệu năng dưới áp lực \cite{jun2018}. Các kịch bản kiểm thử như kiểm tra tăng dần, chịu tải, phá vỡ và độ bền được thiết kế để mô phỏng trường hợp thực tế (tạo đơn hàng, kiểm tra tồn kho, xử lý thanh toán, gửi thông báo).

Benchmarking (Đánh giá) so sánh hiệu năng của các cấu hình hệ thống khác nhau trong điều kiện tiêu chuẩn \cite{richardson2019}. Benchmark được tiến hành cho mỗi mẫu giao tiếp với các trường hợp thử nghiệm giống nhau, từ 10 đến 100 người dùng đồng thời. Các metric thu thập bao gồm thời gian phản hồi, thông lượng, tỷ lệ lỗi và sử dụng tài nguyên.

Profiling (Lập hồ sơ) phân tích chi tiết tài nguyên và thời gian thực thi của các thành phần. Trong Node.js, profiling thực hiện bằng công cụ như Node.js Profiler hoặc clinic.js. Khóa luận sử dụng profiling để phân tích thời gian cho serialization/deserialization, xử lý mạng, logic nghiệp vụ và tương tác database.

Distributed Tracing (Theo dõi phân tán) theo dõi yêu cầu qua nhiều dịch vụ, xác định điểm nghẽn và mối quan hệ phụ thuộc. OpenTelemetry được tích hợp với NestJS thông qua interceptors và middleware. Mỗi trace đại diện cho một yêu cầu và gồm nhiều spans (hoạt động đơn lẻ như HTTP request, database query).

Metrics Collection (Thu thập số liệu) thu thập và phân tích chỉ số hiệu năng theo thời gian. Khóa luận thu thập HTTP metrics, microservice metrics, database metrics, message broker metrics và system metrics, lưu trữ trong time-series database để phân tích xu hướng và thiết lập cảnh báo.

\subsection{Công cụ đo lường hiệu năng}
Để thực hiện các phương pháp trên, khóa luận triển khai bộ công cụ toàn diện \cite{aksakalli2021}. K6, công cụ kiểm thử tải mã nguồn mở dựa trên JavaScript, tạo tải và đo lường hiệu năng \cite{jun2018}. K6 cho phép viết kịch bản phức tạp mô phỏng hành vi thực tế, hỗ trợ HTTP, WebSocket và gRPC, với khả năng mở rộng và tùy chỉnh cao.

Prometheus, hệ thống giám sát mã nguồn mở, thu thập và lưu trữ số liệu hiệu năng từ microservices \cite{richardson2019}. Prometheus sử dụng mô hình pull để truy vấn định kỳ các mục tiêu được cấu hình \cite{newman2015}, cung cấp ngôn ngữ truy vấn PromQL và hệ thống cảnh báo mạnh mẽ. Các microservices được cấu hình để hiển thị endpoint metrics (/metrics) mà Prometheus truy vấn mỗi 15 giây.

Kết hợp các công nghệ triển khai và công cụ đo lường này tạo môi trường toàn diện để đánh giá và so sánh các mẫu giao tiếp. Thông qua thu thập và phân tích dữ liệu từ nhiều góc độ, khóa luận cung cấp cái nhìn sâu sắc về ưu nhược điểm của mỗi mẫu và đưa ra khuyến nghị dựa trên bằng chứng cho việc lựa chọn mẫu phù hợp trong từng tình huống.