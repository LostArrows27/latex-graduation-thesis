\section{Giao tiếp trong kiến trúc vi dịch vụ}

\subsection{Vai trò của giao tiếp trong kiến trúc vi dịch vụ}
Giao tiếp đóng vai trò then chốt trong kiến trúc vi dịch vụ. Khác với các ứng
dụng nguyên khối, các vi dịch vụ giao tiếp qua mạng, thường thông qua HTTP, gRPC hoặc middleware messaging.

Giao tiếp không chỉ trao đổi dữ liệu, mà còn định hình toàn bộ kiến trúc và ảnh hưởng đến tính khả dụng, hiệu suất và khả năng mở rộng của hệ thống \cite{wolff2016}.

Giao tiếp tạo điều kiện cho các dịch vụ phối hợp hoàn thành các tác vụ nghiệp vụ phức tạp. Ví dụ, quy trình đặt hàng liên quan đến các dịch vụ quản lý đơn hàng, thanh toán, kho hàng và vận chuyển cần giao tiếp để đảm bảo xử lý chính xác.

Giao tiếp đóng vai trò quan trọng trong việc đảm bảo tính nhất quán dữ liệu. Trong hệ thống dữ liệu phân tán, mỗi dịch vụ quản lý một phần dữ liệu, cần giao tiếp khi dữ liệu thay đổi để duy trì nhất quán.

Giao tiếp hỗ trợ khả năng chịu lỗi thông qua các cơ chế như Circuit Breaker, giúp hệ thống phục hồi và tiếp tục hoạt động khi gặp lỗi.

Cuối cùng, thiết kế giao tiếp tốt cho phép mở rộng hệ thống, thêm dịch vụ mới hoặc phiên bản mới mà không ảnh hưởng đến dịch vụ khác.

\subsection{Các thuộc tính quan trọng của giao tiếp vi dịch vụ}
Khi thiết kế giao tiếp cho vi dịch vụ, cần xem xét một số thuộc tính quan trọng:

Độ tin cậy đảm bảo thông điệp được gửi và nhận thành công trong hệ thống phân tán. Các cơ chế như xác nhận, thử lại và hàng đợi bền vững giúp tăng độ tin cậy \cite{hohpe2004}.

Độ trễ là thời gian thông điệp di chuyển từ nguồn đến đích. Các yếu tố ảnh hưởng bao gồm khoảng cách vật lý giữa dịch vụ, phương pháp tuần tự hóa và tải mạng.

Khả năng mở rộng giúp xử lý khối lượng thông điệp tăng khi hệ thống phát triển, thông qua việc thêm nhiều phiên bản dịch vụ.

Cách ly lỗi ngăn lỗi lan truyền giữa các dịch vụ. Các mẫu như Circuit Breaker và Bulkhead hạn chế ảnh hưởng của lỗi từ một dịch vụ đến các dịch vụ khác.

Tính nhất quán liên quan đến cách đảm bảo dữ liệu nhất quán. Trong hệ thống phân tán, có sự đánh đổi giữa tính nhất quán, khả năng sẵn sàng và khả năng chịu đựng phân vùng.

Định dạng dữ liệu đề cập cách dữ liệu được cấu trúc và tuần tự hóa. Các định dạng phổ biến như JSON, XML và Protocol Buffers có ưu nhược điểm riêng.

Khả năng tương tác cho phép các dịch vụ sử dụng công nghệ khác nhau giao tiếp với nhau, quan trọng trong môi trường đa ngôn ngữ và đa nền tảng.

Bảo mật bảo vệ thông điệp khỏi truy cập trái phép qua mã hóa, xác thực và ủy quyền khi dịch vụ giao tiếp qua mạng.

\subsection{Các mô hình giao tiếp cơ bản}
Có hai mô hình giao tiếp cơ bản trong vi dịch vụ: đồng bộ và bất đồng bộ.

Trong giao tiếp đồng bộ, người gửi đợi phản hồi trước khi tiếp tục xử lý. Ví dụ, một dịch vụ gửi yêu cầu HTTP đợi phản hồi trước khi tiếp tục. Mô hình này đơn giản, dễ hiểu và cung cấp phản hồi tức thì \cite{newman2015}. Tuy nhiên, có thể dẫn đến hiệu suất kém vì phải đợi phản hồi, hiệu ứng xung hồi khi dịch vụ chậm, và vấn đề khả năng mở rộng khi số yêu cầu tăng.

Trong giao tiếp bất đồng bộ, người gửi không đợi phản hồi. Ví dụ, dịch vụ gửi thông điệp vào hàng đợi rồi tiếp tục xử lý. Mô hình này tạo coupling lỏng lẻo và khả năng đệm tốt \cite{hohpe2004}. Tuy nhiên, phức tạp hơn để triển khai, có thể có độ trễ cao, và gây khó khăn về tính nhất quán dữ liệu.

\subsection{Kiểu tương tác}
Ngoài mô hình giao tiếp đồng bộ và bất đồng bộ, các vi dịch vụ thường tương tác theo hai kiểu chính:

Kiểu one-to-one (một-một): Trong mô hình này, một dịch vụ giao tiếp trực tiếp với một dịch vụ khác. Đây là kiểu tương tác phổ biến nhất trong kiến trúc vi dịch vụ, thường được triển khai thông qua các REST API hoặc RPC. Ví dụ điển hình là dịch vụ đơn hàng gọi dịch vụ thanh toán để xử lý giao dịch, hoặc dịch vụ người dùng truy vấn dịch vụ xác thực để kiểm tra quyền truy cập. Mô hình này đơn giản, dễ triển khai và quản lý, nhưng có thể tạo ra sự phụ thuộc chặt chẽ giữa các dịch vụ.

Kiểu one-to-many (một-nhiều): Trong kiểu tương tác này, một dịch vụ gửi thông điệp hoặc sự kiện đến nhiều dịch vụ khác. Mô hình này thường được triển khai thông qua các cơ chế publish/subscribe (phát hành/đăng ký) sử dụng message broker hoặc event bus. Ví dụ tiêu biểu là khi dịch vụ đơn hàng phát hành sự kiện "đơn hàng đã tạo", các dịch vụ khác như kho hàng, vận chuyển, thông báo và phân tích đều nhận được thông báo này và xử lý tương ứng. Mô hình one-to-many tạo ra sự kết nối lỏng lẻo giữa các dịch vụ, cải thiện khả năng mở rộng và linh hoạt của hệ thống, nhưng cũng làm tăng độ phức tạp trong việc đảm bảo tính nhất quán và theo dõi luồng dữ liệu.

Sự kết hợp giữa mô hình giao tiếp (đồng bộ/bất đồng bộ) và kiểu tương tác (một-một/một-nhiều) tạo ra các mẫu giao tiếp khác nhau, mỗi mẫu phù hợp với các tình huống sử dụng cụ thể trong kiến trúc vi dịch vụ.

\subsection{Các công nghệ và giao thức phổ biến}
HTTP/REST là giao thức phổ biến nhất cho giao tiếp đồng bộ, sử dụng phương thức HTTP và tài nguyên đại diện. REST đơn giản, dễ hiểu và được hỗ trợ rộng rãi.

gRPC là framework RPC hiệu suất cao, sử dụng HTTP/2 và Protocol Buffers. Cung cấp hiệu suất tốt hơn REST nhờ multiplexing và định dạng tuần tự hóa hiệu quả, hỗ trợ streaming hai chiều.

Message Queue là mẫu bất đồng bộ với dịch vụ gửi và nhận thông điệp qua hàng đợi như RabbitMQ, ActiveMQ và AWS SQS. Cung cấp coupling lỏng lẻo và khả năng đệm tốt, nhưng thêm độ phức tạp và độ trễ.

Pub/Sub là mẫu bất đồng bộ với nhà xuất bản gửi thông điệp mà không biết người nhận, thường qua Apache Kafka, AWS SNS/SQS, Google Pub/Sub hoặc NATS. Cung cấp coupling lỏng lẻo cao và khả năng mở rộng tốt.

GraphQL là ngôn ngữ truy vấn và thao tác dữ liệu hiệu quả, cho phép chỉ định chính xác dữ liệu cần thiết, tránh over-fetching và under-fetching \cite{richardson2019}. Hữu ích cho ứng dụng di động với băng thông hạn chế.
 
\subsection{Thách thức trong giao tiếp vi dịch vụ}
Giao tiếp vi dịch vụ đặt ra nhiều thách thức:

Network Reliability là thách thức quan trọng khi mạng không đáng tin cậy, gây mất thông điệp hoặc độ trễ cao. Giải pháp bao gồm retry, timeout và circuit breaker.

Service Discovery giải quyết việc các dịch vụ tìm thấy nhau trong môi trường động. Các giải pháp gồm Client-side Discovery với service registry và Server-side Discovery qua load balancer hoặc API gateway.

Load Balancing phân phối tải giữa các phiên bản dịch vụ, đảm bảo hiệu suất và độ tin cậy. Các cơ chế gồm Round Robin, Least Connections và Hash-based.

Data Consistency là thách thức duy trì tính nhất quán dữ liệu trong giao tiếp vi dịch vụ. Các mẫu như Saga, Event Sourcing và CQRS \cite{richardson2019} giúp quản lý giao dịch phân tán, lưu trạng thái và tách biệt đọc/ghi.

Versioning quản lý thay đổi API giữa các dịch vụ. Các giải pháp gồm Semantic Versioning với hệ thống đánh số (MAJOR.MINOR.PATCH), API Versioning duy trì nhiều phiên bản API, và Backward Compatibility đảm bảo tương thích ngược.

Error Handling xử lý lỗi trong hệ thống phân tán. Các cơ chế gồm Retry thử lại yêu cầu thất bại, Circuit Breaker ngăn yêu cầu đến dịch vụ không phản hồi, và Fallback cung cấp phản hồi thay thế.

Monitoring and Debugging giám sát và gỡ lỗi trong hệ thống phức tạp. Các công cụ gồm Logging tập trung, Distributed Tracing theo dõi yêu cầu qua nhiều dịch vụ, và Metrics Collection thu thập chỉ số hiệu suất.

\subsection{Các mẫu giao tiếp}
Trong kiến trúc vi dịch vụ, các dịch vụ cần trao đổi thông tin để phối hợp và hoàn thành chức năng. Dưới đây là năm mẫu giao tiếp chính:

Request-Response là mẫu đồng bộ phổ biến nhất, dịch vụ gửi yêu cầu đến dịch vụ khác và đợi phản hồi. Dịch vụ gửi thiết lập kết nối HTTP/REST hoặc gRPC, chờ đợi phản hồi từ dịch vụ nhận. Mẫu này đơn giản, dễ hiểu và đảm bảo tính nhất quán dữ liệu cao. Tuy nhiên, tạo coupling chặt chẽ, hiệu suất kém khi độ trễ cao, và có nguy cơ lỗi cascade.

Event-Driven là mẫu các dịch vụ giao tiếp qua phát và lắng nghe sự kiện thông qua message broker. Dịch vụ phát hành không cần biết ai xử lý sự kiện, tạo decoupling cao và khả năng mở rộng tốt. Tuy nhiên, việc theo dõi luồng thực thi và gỡ lỗi phức tạp hơn, khó duy trì tính nhất quán dữ liệu.

Publish-Subscribe là dạng cụ thể của Event-Driven, cho phép phân phối thông tin từ một nguồn đến nhiều người nhận. Publisher gửi thông điệp đến kênh, nhiều subscribers nhận từ kênh đó. Triển khai qua Apache Kafka, RabbitMQ hoặc NATS. Phù hợp cho truyền thông tin một-đến-nhiều, dễ mở rộng, nhưng phức tạp trong quản lý tính nhất quán và có thể xử lý trùng lặp.

Point-to-Point Messaging gửi thông điệp từ nguồn đến đích cụ thể qua hàng đợi. Producer gửi thông điệp vào hàng đợi, chỉ một consumer xử lý mỗi thông điệp. Đảm bảo tin cậy cao, phù hợp cho phân phối tác vụ và cân bằng tải. Tuy nhiên, có thể nghẽn hàng đợi nếu xử lý chậm và không phù hợp khi nhiều dịch vụ cần nhận cùng thông tin.

Asynchronous Request-Response là biến thể bất đồng bộ của Request-Response. Dịch vụ gửi yêu cầu và tiếp tục xử lý, dịch vụ nhận xử lý và gửi phản hồi qua hàng đợi. Dịch vụ gửi được thông báo qua callback, webhook hoặc long polling. Tránh blocking, cải thiện hiệu suất, nhưng phức tạp hơn trong triển khai và quản lý.

Mỗi mẫu có ưu nhược điểm riêng, lựa chọn phù hợp phụ thuộc vào yêu cầu về tính nhất quán, hiệu suất, khả năng mở rộng và độ tin cậy. Thực tế, hệ thống vi dịch vụ thường kết hợp nhiều mẫu để giải quyết các tình huống khác nhau hiệu quả.